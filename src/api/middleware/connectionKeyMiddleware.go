package middleware

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"fmt"
	"log"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"server.com/src/database/mongo"
	"server.com/src/database/redis"
	connection "server.com/src/models"
	user "server.com/src/models/User"
	"server.com/src/utils"
)

func lockUser(id string) error {
	foundUser, err := mongo.Find[user.InternalUser](id)
	if err != nil {
		return err
	}

	if !foundUser.Options.LockOnInvalidConnectionKey {
		return errors.New("cannot lock account")
	}

	err = mongo.UpdateDocument("$set", bson.M{"_id": foundUser.Id}, "is_locked", true)
	if err != nil {
		return err
	}
	return nil
}

func ConnectionKeyMiddleware(g *gin.Context) {
	var connectionKey connection.ConnectionKey

	base64Key := g.GetHeader(utils.CONNECTION_KEY_HEADER)
	if base64Key == "" {
		g.AbortWithStatusJSON(400, gin.H{
			"error": fmt.Sprintf("please set %s", utils.CONNECTION_KEY_HEADER),
		})
		return
	}

	connectionKey, keyBytes, err := utils.DecodeConnectionKey(base64Key)
	if err != nil {
		g.JSON(400, gin.H{
			"err": err.Error(),
		})
		return
	}

	foundUser, err := mongo.Find[user.InternalUser](connectionKey.OwnedBy)
	if err != nil {
		g.AbortWithStatusJSON(400, err.Error())
		return
	}

	hasher := hmac.New(sha256.New, []byte(foundUser.Password))
	if _, err := hasher.Write(keyBytes); err != nil {
		log.Print(err)

		g.AbortWithStatusJSON(400, err.Error())
		return
	}
	computedHmac := hasher.Sum(nil)

	Hmac, err := base64.RawStdEncoding.DecodeString(
		redis.GetString(connectionKey.ConnectionKeyID),
	)

	if err != nil {
		log.Println(lockUser(foundUser.Id))
		g.AbortWithStatusJSON(400, err.Error())
		return
	}

	if !hmac.Equal(Hmac, computedHmac) {
		log.Println(lockUser(foundUser.Id))
		g.AbortWithStatusJSON(401, "connection key does not match id")
		return
	}
}
