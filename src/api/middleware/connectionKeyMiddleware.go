package middleware

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"

	"go.mongodb.org/mongo-driver/bson"
	"server.com/src/database/mongo"
	"server.com/src/database/redis"
	connection "server.com/src/models"
	user "server.com/src/models/User"
	"server.com/src/utils"
)

func lockUser(id string) error {
	foundUser, err := mongo.Find[user.InternalUser](id)
	if err != nil {
		return err
	}

	if !foundUser.Options.LockOnInvalidConnectionKey {
		return errors.New("cannot lock account")
	}

	err = mongo.UpdateDocument("$set", bson.M{"_id": foundUser.Id}, "is_locked", true)
	if err != nil {
		return err
	}
	return nil
}

func MiddlewareBody(w http.ResponseWriter, req *http.Request) {
	var connectionKey connection.ConnectionKey

	base64Key := w.Header().Get(utils.CONNECTION_KEY_HEADER)
	if base64Key == "" {
		http.Error(w, fmt.Sprintf("please set %s", utils.CONNECTION_KEY_HEADER), 400)
		return
	}

	decodedToken, err := base64.RawStdEncoding.DecodeString(base64Key)
	if err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	err = json.Unmarshal(decodedToken, &connectionKey)
	if err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	foundUser, err := mongo.Find[user.InternalUser](connectionKey.OwnedBy)
	if err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	hasher := hmac.New(sha256.New, []byte(foundUser.Password))
	if _, err := hasher.Write(decodedToken); err != nil {
		log.Print(err)

		http.Error(w, err.Error(), 400)
		return
	}
	computedHmac := hasher.Sum(nil)

	Hmac, err := base64.RawStdEncoding.DecodeString(
		redis.GetString(connectionKey.ConnectionKeyID),
	)

	if err != nil {
		log.Println(lockUser(foundUser.Id))
		http.Error(w, err.Error(), 400)
		return
	}

	if !hmac.Equal(Hmac, computedHmac) {
		log.Println(lockUser(foundUser.Id))
		http.Error(w, "connection key does not match id", 401)
		return
	}
}
