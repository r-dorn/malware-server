package routes

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"time"

	"server.com/src/database/redis"
	"server.com/src/utils"

	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"golang.org/x/crypto/bcrypt"
	"server.com/src/config"
	"server.com/src/database/mongo"
	connection "server.com/src/models"
	user "server.com/src/models/User"
)

var SERVER_CONFIG config.ServerConfig
var DEFAULT_DURATION time.Duration = time.Hour * 2

func CreateUser(g *gin.Context) {
	var NewUser user.User

	err := g.ShouldBindJSON(&NewUser)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	databaseUser, err := user.InternalUser{}.New(NewUser)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	generatedID, err := mongo.InsertDocument(databaseUser, bson.M{
		"username": NewUser.Username,
	})
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	g.JSON(200, map[string]string{"user_id": generatedID})
}

func LoginUser(g *gin.Context) {
	var loginRequest user.User
	sessionManager := sessions.Default(g)

	err := g.ShouldBindJSON(&loginRequest)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	foundUser, err := mongo.FindByQueryGeneric[user.InternalUser](bson.M{
		"username": loginRequest.Username,
	})

	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	if foundUser.IsLocked {
		g.JSON(401, utils.LockedAccountResponse)
		return
	}

	err = bcrypt.CompareHashAndPassword([]byte(foundUser.Password), []byte(loginRequest.Password))
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	sessionManager.Set(utils.SESSION_KEY, foundUser.Id)
	err = sessionManager.Save()
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	g.JSON(200, gin.H{"success": "Successfully logged in"})
}

func GetMe(g *gin.Context) {
	manager := sessions.Default(g)

	userID := manager.Get(utils.SESSION_KEY)
	if userID == nil {
		g.JSON(400, gin.H{"error": "please login before accessing this endpoint"})
		return
	}

	foundUser, err := mongo.Find[user.InternalUser](userID.(string))
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	g.JSON(200, gin.H{
		"id":            foundUser.Id,
		"username":      foundUser.Username,
		"owned_clients": foundUser.ConnectedClients,
	})
}

func ObtainConnectionKey(g *gin.Context) {
	manager := sessions.Default(g)

	userID := manager.Get(utils.SESSION_KEY)
	if userID == nil {
		g.JSON(401, gin.H{
			"error": "please login first",
		})
		return
	}

	foundUser, err := mongo.Find[user.InternalUser](userID.(string))
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	key, err := connection.GenerateConnectionKey(userID.(string), 15, time.Hour*3)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	calculatedHmac, err := key.CalcuateConnectionKeyHmac(
		[]byte(foundUser.Password),
		key,
	)

	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	err = redis.InsertTTL(key.ConnectionKeyID, calculatedHmac, DEFAULT_DURATION)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	keyBytes, err := json.Marshal(key)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	encodedKey := base64.RawStdEncoding.EncodeToString(keyBytes)
	g.JSON(200, connection.JsonConnectionKey{
		EncodedKey: encodedKey,
	})
}

func Logout(c *gin.Context) {
	manager := sessions.Default(c)

	if manager.Get(utils.SESSION_KEY) == "" {
		c.AbortWithStatusJSON(401, gin.H{
			"error": "please login first",
		})
		return
	}
	manager.Clear()

	c.JSON(200, gin.H{
		"success": "user was successfully logged out",
	})
}

func RevokeConnectionKey(g *gin.Context) {
	var ConnectionKey string = g.GetHeader(utils.CONNECTION_KEY_HEADER)

	if ConnectionKey == "" {
		g.JSON(400, gin.H{
			"error": "please provide a valid connection key",
		})
		return
	}

	JsonConnectionKey, _, err := utils.DecodeConnectionKey(ConnectionKey)
	if err != nil {
		g.JSON(400, gin.H{
			"error": "please provide a valid connection key",
		})
		return
	}

	err = redis.Database.Del(context.TODO(), JsonConnectionKey.ConnectionKeyID).Err()
	if err != nil {
		g.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
		return
	}

	g.JSON(200, gin.H{
		"success": "key was sucessfully revoked",
	})
}
