package routes

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"log"
	"os"
	"path/filepath"
	"time"

	"server.com/src/database/redis"

	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"golang.org/x/crypto/bcrypt"
	"server.com/src/config"
	"server.com/src/database/mongo"
	"server.com/src/database/sqlite"
	connection "server.com/src/models"
	user "server.com/src/models/User"
)

var SERVER_CONFIG config.ServerConfig
var DEFAULT_DURATION time.Duration = time.Hour * 2

func init() {
	dir, err := os.UserConfigDir()
	if err != nil {
		log.Fatal(err)
	}
	SERVER_CONFIG = sqlite.LoadConfig(sqlite.Open(filepath.Join(
		dir,
		sqlite.DEFAULT_FILENAME,
	)))
	mongo.ConnectDatabase(config.Load[config.Settings]())
}

// CreateUser  godoc
// @Summary create user
// @Schemes
// @Description add new user to database
// @Tags user
// @Accept json
// @Produce json
// @Success 200 {object} user.InternalUser
// @Router /api/v1/user/create/user [post]
// @Param        user  body      user.User  true  "new user"
func CreateUser(g *gin.Context) {
	var NewUser user.User

	err := g.ShouldBindJSON(&NewUser)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	databaseUser, err := user.InternalUser{}.New(NewUser)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	generatedID, err := mongo.InsertDocument(databaseUser, bson.D{{
		Key: "username", Value: NewUser.Username,
	}})
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	g.JSON(200, map[string]string{"user_id": generatedID})
}

// LoginUser  godoc
// @Summary login to user account
//
//	@Schemes
//
// @Description login user
// @Tags user
// @Accept json
// @Produce json
// @Success 200 {object} user.User
// @Router /api/v1/user/login [post]
// @Param        login-request  body      user.User  true  "login user"
func LoginUser(g *gin.Context) {
	var loginRequest user.User
	sessionManager := sessions.Default(g)

	err := g.ShouldBindJSON(&loginRequest)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	foundUser, err := mongo.FindByQuery[user.InternalUser](bson.D{{
		Key: "username", Value: loginRequest.Username,
	}})
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	err = bcrypt.CompareHashAndPassword([]byte(foundUser.Password), []byte(loginRequest.Password))
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	sessionManager.Set(config.DATABASE_SETTINGS.SessionKey, foundUser.Id)
	sessionManager.AddFlash("Successfully logged in")
	if err := sessionManager.Save(); err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	g.JSON(200, gin.H{"success": "Successfully logged in"})
}

// GetMe  godoc
// @Summary login to user account
//
//	@Schemes
//
// @Description login user
// @Tags user
// @Accept json
// @Produce json
// @Success 200 {object} user.User
// @Router /api/v1/user/me [get]
func GetMe(g *gin.Context) {
	manager := sessions.Default(g)

	userID := manager.Get(config.DATABASE_SETTINGS.SessionKey).(string)
	if userID == "" {
		g.JSON(400, gin.H{"error": "please login before accessing this endpoint"})
		return
	}
	foundUser, err := mongo.Find[user.InternalUser](userID)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	g.JSON(200, user.User{
		Username: foundUser.Username,
	})
}

// ObtainConnectionKey @Summary get a valid connection key
//
//	@Schemes
//
// @Description obtain connection key
// @Tags user
// @Accept json
// @Produce json
// @Success 200 {object} connection.ConnectionKey
// @Router /api/v1/user/connection-key [get]
func ObtainConnectionKey(g *gin.Context) {
	manager := sessions.Default(g)

	userID := manager.Get(config.DATABASE_SETTINGS.SessionKey).(string)

	foundUser, err := mongo.Find[user.InternalUser](userID)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	key, err := connection.GenerateConnectionKey(userID, 15, time.Hour*3)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	calculatedHmac, err := connection.CalcuateConnectionKeyHmac(
		[]byte(foundUser.Password),
		key,
	)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	err = redis.Insert(key.ConnectionKeyID, calculatedHmac, DEFAULT_DURATION)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	g.JSON(200, key)
}

// VerifyConnectionKey @Summary verify a valid connection key
//
//	@Schemes
//
// @Description verify a provided connection key
// @Tags user
// @Accept json
// @Produce json
// @Success 200 {object} bool
// @Param        connection-key  body      connection.ConnectionKey  true  "connection key"
// @Router /api/v1/user/verify/connection-key [post]
func VerifyConnectionKey(g *gin.Context) {
	var ConnectionBody connection.ConnectionKey

	err := g.ShouldBindJSON(&ConnectionBody)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	foundHmac := redis.GetString(ConnectionBody.ConnectionKeyID)
	if foundHmac == "" {
		g.JSON(400, gin.H{"error": "id does not exist"})
		return

	}

	decodedHmac, err := base64.RawStdEncoding.DecodeString(foundHmac)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	foundUser, err := mongo.Find[user.InternalUser](ConnectionBody.OwnedBy)

	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}

	hasher := hmac.New(sha256.New, []byte(foundUser.Password))
	rawData, err := json.Marshal(&ConnectionBody)
	if err != nil {
		g.JSON(400, gin.H{"error": err.Error()})
		return
	}
	hasher.Write(rawData)
	g.JSON(200, gin.H{
		"success": hmac.Equal(decodedHmac, hasher.Sum(nil)),
	})
}
