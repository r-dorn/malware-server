package mongo

import (
	"context"
	"errors"
	"log"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"server.com/src/config"
)

var Col mongo.Collection

func init() {
	ConnectDatabase(config.DATABASE_SETTINGS)
}

func ConnectDatabase(dbSettings config.Settings) {
	client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(
		dbSettings.Mongodb.Connection,
	))
	if err != nil {
		log.Fatal(err)
	}
	Col = *client.Database(dbSettings.Mongodb.Database).Collection(dbSettings.Mongodb.Collection)
}

func DocumentExists(query bson.M) bool {
	amount, err := Col.CountDocuments(context.TODO(), query, options.Count().SetLimit(1))
	return amount == 1 && err == nil
}

func FindByQueryGeneric[T any](query bson.M) (T, error) {
	var decodedDocument T

	if !DocumentExists(query) {
		return *new(T), errors.New("no documents matching provided query")
	}
	res := Col.FindOne(context.TODO(), query)

	err := res.Decode(&decodedDocument)
	if err != nil {
		return *new(T), err
	}
	return decodedDocument, nil
}

func Find[T any](id string) (T, error) {
	var result T

	if !DocumentExists(bson.M{"_id": id}) {
		return *new(T), errors.New("id does not exist")
	}
	err := Col.FindOne(context.TODO(), bson.D{{Key: "_id", Value: id}}).Decode(&result)
	return result, err
}

func InsertDocument[T any](document T, existingQuery bson.M) (string, error) {
	if DocumentExists(existingQuery) {
		return "", errors.New("cannot insert conflicting document")
	}
	result, err := Col.InsertOne(context.TODO(), document)
	return result.InsertedID.(string), err
}

func UpdateDocument[FieldType any](operation string, query bson.M, targetField string, value FieldType) error {
	if !DocumentExists(query) {
		return errors.New("no documents matching query")
	}
	return Col.FindOneAndUpdate(context.TODO(), query, bson.M{operation: bson.D{{
		Key:   targetField,
		Value: value,
	}}}).Err()
}
